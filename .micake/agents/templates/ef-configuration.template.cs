//------------------------------------------------------------------------------
// MiCake EF Core Configuration Template
// Generated by MiCake Agent System
//------------------------------------------------------------------------------
// Template Variables:
// - {{Namespace}}: Infrastructure namespace
// - {{AggregateName}}: Name of the aggregate to configure
// - {{TableName}}: Database table name
// - {{Properties}}: Property configurations
// - {{ValueObjects}}: Value object mappings
// - {{ChildEntities}}: Child entity configurations
//------------------------------------------------------------------------------

using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using {{DomainNamespace}}.Aggregates;
using {{DomainNamespace}}.ValueObjects;

namespace {{Namespace}}.Configurations;

/// <summary>
/// EF Core configuration for <see cref="{{AggregateName}}"/> aggregate.
/// </summary>
public class {{AggregateName}}Configuration : IEntityTypeConfiguration<{{AggregateName}}>
{
    public void Configure(EntityTypeBuilder<{{AggregateName}}> builder)
    {
        #region Table Configuration
        
        builder.ToTable("{{TableName}}");
        
        // Primary key
        builder.HasKey(e => e.Id);
        
        // ID configuration (for database-generated IDs)
        builder.Property(e => e.Id)
            .ValueGeneratedOnAdd();
        
        #endregion
        
        #region Property Configurations
        
        {{#each Properties}}
        builder.Property(e => e.{{name}})
            {{#if isRequired}}.IsRequired(){{/if}}
            {{#if maxLength}}.HasMaxLength({{maxLength}}){{/if}}
            {{#if columnName}}.HasColumnName("{{columnName}}"){{/if}}
            {{#if columnType}}.HasColumnType("{{columnType}}"){{/if}};
        
        {{/each}}
        
        #endregion
        
        #region Value Object Configurations
        
        {{#each ValueObjects}}
        // {{name}} value object (owned type)
        builder.OwnsOne(e => e.{{name}}, vo =>
        {
            {{#each components}}
            vo.Property(v => v.{{name}})
                .HasColumnName("{{columnName}}")
                {{#if isRequired}}.IsRequired(){{/if}};
            {{/each}}
        });
        
        {{/each}}
        
        #endregion
        
        #region Child Entity Configurations
        
        {{#each ChildEntities}}
        // {{entityType}} child entities
        builder.OwnsMany(e => e.{{collectionName}}, child =>
        {
            child.ToTable("{{tableName}}");
            child.WithOwner().HasForeignKey("{{parentForeignKey}}");
            child.HasKey("{{parentForeignKey}}", "Id");
            
            {{#each properties}}
            child.Property(c => c.{{name}})
                {{#if isRequired}}.IsRequired(){{/if}}
                {{#if maxLength}}.HasMaxLength({{maxLength}}){{/if}};
            {{/each}}
            
            {{#each valueObjects}}
            // Nested value object
            child.OwnsOne(c => c.{{name}}, nvo =>
            {
                {{#each components}}
                nvo.Property(v => v.{{name}}).HasColumnName("{{columnName}}");
                {{/each}}
            });
            {{/each}}
        });
        
        {{/each}}
        
        #endregion
        
        #region Relationships
        
        {{#each Relationships}}
        // Relationship to {{relatedEntity}}
        builder.HasOne<{{relatedEntity}}>()
            .WithMany()
            .HasForeignKey(e => e.{{foreignKey}})
            .OnDelete(DeleteBehavior.{{deleteBehavior}});
        
        {{/each}}
        
        #endregion
        
        #region Indexes
        
        {{#each Indexes}}
        builder.HasIndex(e => e.{{property}})
            {{#if isUnique}}.IsUnique(){{/if}}
            {{#if name}}.HasDatabaseName("{{name}}"){{/if}};
        
        {{/each}}
        
        #endregion
    }
}

//------------------------------------------------------------------------------
// EXAMPLES
//------------------------------------------------------------------------------

/*
// Example 1: Complete Order configuration
public class OrderConfiguration : IEntityTypeConfiguration<Order>
{
    public void Configure(EntityTypeBuilder<Order> builder)
    {
        // Table
        builder.ToTable("Orders");
        builder.HasKey(e => e.Id);
        builder.Property(e => e.Id).ValueGeneratedOnAdd();
        
        // Simple properties
        builder.Property(e => e.CustomerId)
            .IsRequired();
        
        builder.Property(e => e.OrderDate)
            .IsRequired();
        
        builder.Property(e => e.Status)
            .IsRequired()
            .HasConversion<string>()  // Store enum as string
            .HasMaxLength(50);
        
        // Value object: TotalAmount (Money)
        builder.OwnsOne(e => e.TotalAmount, money =>
        {
            money.Property(m => m.Amount)
                .HasColumnName("TotalAmount")
                .HasColumnType("decimal(18,2)")
                .IsRequired();
            
            money.Property(m => m.Currency)
                .HasColumnName("Currency")
                .HasMaxLength(3)
                .IsRequired();
        });
        
        // Child entities: OrderItems
        builder.OwnsMany(e => e.Items, item =>
        {
            item.ToTable("OrderItems");
            item.WithOwner().HasForeignKey("OrderId");
            item.HasKey("OrderId", "Id");
            
            item.Property(i => i.ProductId).IsRequired();
            item.Property(i => i.ProductName).HasMaxLength(200).IsRequired();
            item.Property(i => i.Quantity).IsRequired();
            
            // Nested value object: Price (Money)
            item.OwnsOne(i => i.Price, price =>
            {
                price.Property(p => p.Amount)
                    .HasColumnName("UnitPrice")
                    .HasColumnType("decimal(18,2)")
                    .IsRequired();
                
                price.Property(p => p.Currency)
                    .HasColumnName("PriceCurrency")
                    .HasMaxLength(3)
                    .IsRequired();
            });
        });
        
        // Indexes
        builder.HasIndex(e => e.CustomerId)
            .HasDatabaseName("IX_Orders_CustomerId");
        
        builder.HasIndex(e => e.OrderDate)
            .HasDatabaseName("IX_Orders_OrderDate");
        
        builder.HasIndex(e => new { e.CustomerId, e.Status })
            .HasDatabaseName("IX_Orders_CustomerId_Status");
    }
}

// Example 2: Value object with multiple components
public class AddressConfiguration : IEntityTypeConfiguration<Customer>
{
    public void Configure(EntityTypeBuilder<Customer> builder)
    {
        builder.OwnsOne(e => e.Address, address =>
        {
            address.Property(a => a.Street)
                .HasColumnName("Address_Street")
                .HasMaxLength(200)
                .IsRequired();
            
            address.Property(a => a.City)
                .HasColumnName("Address_City")
                .HasMaxLength(100)
                .IsRequired();
            
            address.Property(a => a.PostalCode)
                .HasColumnName("Address_PostalCode")
                .HasMaxLength(20);
            
            address.Property(a => a.Country)
                .HasColumnName("Address_Country")
                .HasMaxLength(100)
                .IsRequired();
        });
    }
}

// Example 3: Enum conversion
public class ProductConfiguration : IEntityTypeConfiguration<Product>
{
    public void Configure(EntityTypeBuilder<Product> builder)
    {
        builder.Property(e => e.Category)
            .HasConversion<string>()  // Store as string
            .HasMaxLength(50)
            .IsRequired();
        
        // Or use value converter for custom mapping
        builder.Property(e => e.Status)
            .HasConversion(
                v => v.ToString(),
                v => Enum.Parse<ProductStatus>(v))
            .HasMaxLength(50);
    }
}
*/

//------------------------------------------------------------------------------
// CONFIGURATION BEST PRACTICES
//------------------------------------------------------------------------------
/*
✅ Good practices:
1. One configuration class per aggregate
2. Use OwnsOne for value objects (not separate tables)
3. Use OwnsMany for child entities within aggregate boundary
4. Add indexes for frequently queried columns
5. Use HasMaxLength for string properties
6. Use HasColumnType for precise decimal/money types
7. Store enums as strings for readability

❌ Avoid:
1. Lazy loading (can cause N+1 problems)
2. Bidirectional navigation properties
3. Foreign key navigation to other aggregates (use ID reference only)
4. Complex inheritance hierarchies in EF

Value Object Mapping Rules:
- Use OwnsOne for single value objects
- Use OwnsMany for collections of value objects
- Value objects don't have their own Id
- Value objects are stored in the same table as the owner (or separate table with OwnsMany)

Child Entity Rules:
- Child entities within aggregate use OwnsMany
- Child entities outside aggregate (other aggregates) use HasOne/HasMany with ID reference
- Use composite key (ParentId, Id) for child entities
*/
