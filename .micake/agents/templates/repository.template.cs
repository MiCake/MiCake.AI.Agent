//------------------------------------------------------------------------------
// MiCake Repository Interface Template
// Generated by MiCake Agent System
//------------------------------------------------------------------------------
// Template Variables:
// - {{Namespace}}: Root namespace (Domain layer)
// - {{AggregateName}}: Name of the aggregate
// - {{IdType}}: Type of the aggregate ID
// - {{CustomMethods}}: Additional query/command methods
//------------------------------------------------------------------------------

using MiCake.DDD.Domain;

namespace {{Namespace}}.Repositories;

/// <summary>
/// Repository interface for <see cref="{{AggregateName}}"/> aggregate.
/// </summary>
/// <remarks>
/// This interface is placed in the Domain layer.
/// Implementation is in the Infrastructure layer.
/// MiCake provides base CRUD operations through IRepository.
/// </remarks>
public interface I{{AggregateName}}Repository : IRepository<{{AggregateName}}, {{IdType}}>
{
    {{#each CustomMethods}}
    /// <summary>
    /// {{description}}
    /// </summary>
    {{#each parameters}}
    /// <param name="{{name}}">{{description}}</param>
    {{/each}}
    /// <returns>{{returnDescription}}</returns>
    {{returnType}} {{name}}({{parameterList}});
    
    {{/each}}
}

//------------------------------------------------------------------------------
// MiCake Repository Implementation Template
// Location: Infrastructure/Repositories/
//------------------------------------------------------------------------------

using Microsoft.EntityFrameworkCore;
using MiCake.EntityFrameworkCore.Repository;
using {{Namespace}}.Repositories;

namespace {{InfrastructureNamespace}}.Repositories;

/// <summary>
/// EF Core implementation of <see cref="I{{AggregateName}}Repository"/>.
/// </summary>
public class {{AggregateName}}Repository 
    : EFRepository<{{AggregateName}}, {{IdType}}, {{DbContextName}}>, 
      I{{AggregateName}}Repository
{
    public {{AggregateName}}Repository({{DbContextName}} dbContext) 
        : base(dbContext)
    {
    }
    
    {{#each CustomMethods}}
    /// <inheritdoc/>
    public {{returnType}} {{name}}({{parameterList}})
    {
        {{implementation}}
    }
    
    {{/each}}
}

//------------------------------------------------------------------------------
// EXAMPLES
//------------------------------------------------------------------------------

/*
// Example 1: Order Repository Interface (Domain Layer)
// Location: Domain/Repositories/IOrderRepository.cs

using MiCake.DDD.Domain;
using MyShop.Domain.Aggregates;

namespace MyShop.Domain.Repositories;

public interface IOrderRepository : IRepository<Order, long>
{
    /// <summary>
    /// Gets all orders for a specific customer.
    /// </summary>
    Task<IReadOnlyList<Order>> GetByCustomerIdAsync(
        long customerId, 
        CancellationToken cancellationToken = default);
    
    /// <summary>
    /// Gets orders within a date range.
    /// </summary>
    Task<IReadOnlyList<Order>> GetByDateRangeAsync(
        DateTime startDate, 
        DateTime endDate, 
        CancellationToken cancellationToken = default);
    
    /// <summary>
    /// Gets pending orders older than specified duration.
    /// </summary>
    Task<IReadOnlyList<Order>> GetStalePendingOrdersAsync(
        TimeSpan olderThan, 
        CancellationToken cancellationToken = default);
    
    /// <summary>
    /// Checks if customer has any active orders.
    /// </summary>
    Task<bool> HasActiveOrdersAsync(
        long customerId, 
        CancellationToken cancellationToken = default);
}

// Example 2: Order Repository Implementation (Infrastructure Layer)
// Location: Infrastructure/Repositories/OrderRepository.cs

using Microsoft.EntityFrameworkCore;
using MiCake.EntityFrameworkCore.Repository;
using MyShop.Domain.Aggregates;
using MyShop.Domain.Repositories;

namespace MyShop.Infrastructure.Repositories;

public class OrderRepository : EFRepository<Order, long, MyShopDbContext>, IOrderRepository
{
    public OrderRepository(MyShopDbContext dbContext) : base(dbContext)
    {
    }
    
    public async Task<IReadOnlyList<Order>> GetByCustomerIdAsync(
        long customerId, 
        CancellationToken cancellationToken = default)
    {
        return await DbSet
            .Where(o => o.CustomerId == customerId)
            .Include(o => o.Items)
            .OrderByDescending(o => o.OrderDate)
            .ToListAsync(cancellationToken);
    }
    
    public async Task<IReadOnlyList<Order>> GetByDateRangeAsync(
        DateTime startDate, 
        DateTime endDate, 
        CancellationToken cancellationToken = default)
    {
        return await DbSet
            .Where(o => o.OrderDate >= startDate && o.OrderDate <= endDate)
            .Include(o => o.Items)
            .ToListAsync(cancellationToken);
    }
    
    public async Task<IReadOnlyList<Order>> GetStalePendingOrdersAsync(
        TimeSpan olderThan, 
        CancellationToken cancellationToken = default)
    {
        var threshold = DateTime.UtcNow - olderThan;
        return await DbSet
            .Where(o => o.Status == OrderStatus.Pending && o.OrderDate < threshold)
            .ToListAsync(cancellationToken);
    }
    
    public async Task<bool> HasActiveOrdersAsync(
        long customerId, 
        CancellationToken cancellationToken = default)
    {
        return await DbSet
            .AnyAsync(o => 
                o.CustomerId == customerId && 
                o.Status != OrderStatus.Completed && 
                o.Status != OrderStatus.Cancelled,
                cancellationToken);
    }
}
*/

//------------------------------------------------------------------------------
// REPOSITORY BEST PRACTICES
//------------------------------------------------------------------------------
/*
✅ Good practices:
1. Repository works with aggregate roots only
2. Interface in Domain layer, implementation in Infrastructure
3. Return IReadOnlyList for collections (not IQueryable)
4. Include navigation properties as needed
5. Use cancellation tokens consistently
6. Keep repository methods focused on single responsibility

❌ Avoid:
1. Exposing IQueryable (leaks EF Core details to domain)
2. Generic "GetAll" without pagination for large datasets
3. Complex business logic in repository (belongs in domain)
4. Multiple aggregate modifications in single repository method
5. Returning domain objects from complex queries (use DTOs in Application layer)

Query Patterns:
- GetByIdAsync(id) - inherited from IRepository
- FindAsync(id) - inherited, returns null if not found
- GetBy{Property}Async - filter by single property
- Get{Description}Async - complex query with clear intent
- Exists{Condition}Async / Has{Condition}Async - boolean checks
- Count{Condition}Async - counting queries
*/
