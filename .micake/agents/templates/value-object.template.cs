//------------------------------------------------------------------------------
// MiCake Value Object Template
// Generated by MiCake Agent System
//------------------------------------------------------------------------------
// Template Variables:
// - {{Namespace}}: Root namespace
// - {{ValueObjectName}}: Name of the value object
// - {{Components}}: List of components that make up the value object
// - {{UseRecordSyntax}}: Whether to use C# record syntax (recommended for C# 9+)
//------------------------------------------------------------------------------

using MiCake.DDD.Domain;

namespace {{Namespace}}.ValueObjects;

{{#if UseRecordSyntax}}
//------------------------------------------------------------------------------
// Record-based Value Object (Recommended for C# 9+)
// Uses RecordValueObject for automatic equality and immutability
//------------------------------------------------------------------------------

/// <summary>
/// {{ValueObjectName}} value object.
/// </summary>
/// <remarks>
/// Value objects are immutable and compared by their component values.
/// </remarks>
{{#each Components}}
/// <param name="{{name}}">{{description}}</param>
{{/each}}
public sealed record {{ValueObjectName}}(
    {{#each Components}}
    {{type}} {{name}}{{#unless @last}},{{/unless}}
    {{/each}}
) : RecordValueObject;

{{else}}
//------------------------------------------------------------------------------
// Class-based Value Object (For complex validation or computed properties)
//------------------------------------------------------------------------------

/// <summary>
/// {{ValueObjectName}} value object.
/// </summary>
/// <remarks>
/// Value objects are immutable and compared by their component values.
/// </remarks>
public sealed class {{ValueObjectName}} : ValueObject
{
    #region Components
    
    {{#each Components}}
    /// <summary>
    /// Gets the {{description}}.
    /// </summary>
    public {{type}} {{name}} { get; }
    
    {{/each}}
    
    #endregion
    
    #region Constructor
    
    /// <summary>
    /// Creates a new <see cref="{{ValueObjectName}}"/> instance.
    /// </summary>
    {{#each Components}}
    /// <param name="{{camelName}}">{{description}}</param>
    {{/each}}
    public {{ValueObjectName}}({{ConstructorParameterList}})
    {
        {{#each Validations}}
        if ({{condition}})
        {
            throw new ArgumentException("{{message}}", nameof({{paramName}}));
        }
        {{/each}}
        
        {{#each Components}}
        {{name}} = {{camelName}};
        {{/each}}
    }
    
    #endregion
    
    #region Equality
    
    /// <inheritdoc/>
    protected override IEnumerable<object?> GetEqualityComponents()
    {
        {{#each Components}}
        yield return {{name}};
        {{/each}}
    }
    
    #endregion
    
    #region Operations
    
    {{#each Operations}}
    /// <summary>
    /// {{description}}
    /// </summary>
    public {{returnType}} {{name}}({{parameterList}})
    {
        {{body}}
    }
    
    {{/each}}
    
    #endregion
    
    #region Formatting
    
    /// <inheritdoc/>
    public override string ToString()
    {
        return $"{{FormatString}}";
    }
    
    #endregion
}

{{/if}}

//------------------------------------------------------------------------------
// EXAMPLES
//------------------------------------------------------------------------------

/*
// Example 1: Money value object (Record-based)
public sealed record Money(
    decimal Amount,
    string Currency
) : RecordValueObject
{
    // Additional validation in constructor if needed
    public Money(decimal amount, string currency) : this(
        amount >= 0 ? amount : throw new ArgumentException("Amount cannot be negative"),
        !string.IsNullOrWhiteSpace(currency) ? currency.ToUpperInvariant() : throw new ArgumentException("Currency is required")
    )
    {
    }
    
    // Operations
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Cannot add money with different currencies");
        return this with { Amount = Amount + other.Amount };
    }
    
    public Money Multiply(decimal factor)
    {
        return this with { Amount = Amount * factor };
    }
}

// Example 2: Address value object (Class-based)
public sealed class Address : ValueObject
{
    public string Street { get; }
    public string City { get; }
    public string PostalCode { get; }
    public string Country { get; }
    
    public Address(string street, string city, string postalCode, string country)
    {
        if (string.IsNullOrWhiteSpace(street))
            throw new ArgumentException("Street is required", nameof(street));
        if (string.IsNullOrWhiteSpace(city))
            throw new ArgumentException("City is required", nameof(city));
        if (string.IsNullOrWhiteSpace(country))
            throw new ArgumentException("Country is required", nameof(country));
        
        Street = street;
        City = city;
        PostalCode = postalCode ?? string.Empty;
        Country = country;
    }
    
    protected override IEnumerable<object?> GetEqualityComponents()
    {
        yield return Street;
        yield return City;
        yield return PostalCode;
        yield return Country;
    }
    
    public override string ToString()
    {
        return $"{Street}, {City} {PostalCode}, {Country}";
    }
}

// Example 3: Email value object (Simple validation)
public sealed record Email : RecordValueObject
{
    public string Value { get; }
    
    public Email(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Email is required");
        if (!value.Contains('@'))
            throw new ArgumentException("Invalid email format");
        
        Value = value.ToLowerInvariant();
    }
    
    public static implicit operator string(Email email) => email.Value;
    public override string ToString() => Value;
}

// Example 4: DateRange value object
public sealed record DateRange(
    DateTime Start,
    DateTime End
) : RecordValueObject
{
    public DateRange(DateTime start, DateTime end) : this(
        start,
        end >= start ? end : throw new ArgumentException("End must be after Start")
    )
    {
    }
    
    public int Days => (End - Start).Days;
    
    public bool Contains(DateTime date) => date >= Start && date <= End;
    
    public bool Overlaps(DateRange other) =>
        Start < other.End && End > other.Start;
}
*/
